        -:    0:Source:src/testar.c
        -:    1:#include <CUnit/CUnit.h>
        -:    2:#include <CUnit/Basic.h>
        -:    3:#include <stdio.h>
        -:    4:#include <stdlib.h>
        -:    5:#include <string.h>
        -:    6:#include "jogo.h"
        -:    7:
        3:    8:void criar_ficheiro_teste(const char* nome_ficheiro) {
        3:    9:    FILE* f = fopen(nome_ficheiro, "w");
       3*:   10:    fprintf(f, "5 5\n");
       3*:   11:    fprintf(f, "ecadc\n");
       3*:   12:    fprintf(f, "dcdec\n");
       3*:   13:    fprintf(f, "bddce\n");
       3*:   14:    fprintf(f, "cdeeb\n");
       3*:   15:    fprintf(f, "accbb\n");
       3*:   16:    fclose(f);
        3:   17:}
        -:   18:
        3:   19:void test_carregar(void) {
        3:   20:    criar_ficheiro_teste("tabuleiro.txt");
        -:   21:
        -:   22:    // Inicializando a pilha
        3:   23:    Pilha pilha;
        3:   24:    inicializarPilha(&pilha, 10);
        -:   25:
        -:   26:    // Carregando o tabuleiro
        3:   27:    Tabuleiro* tab = carregar("tabuleiro.txt", &pilha);
        -:   28:
        -:   29:    // Verifique se o tabuleiro não é NULL
        3:   30:    if (tab == NULL) {
    #####:   31:        CU_FAIL("Falha ao carregar o tabuleiro");
    #####:   32:        freePilha(&pilha);  // Libera a pilha caso o carregamento falhe
    #####:   33:        return;  // Interrompe o teste se o tabuleiro for NULL
        -:   34:    }
        -:   35:
        -:   36:    // Realiza os asserts para validar os dados carregados
        3:   37:    CU_ASSERT_PTR_NOT_NULL(tab);
        3:   38:    CU_ASSERT_EQUAL(tab->linhas, 5);
        3:   39:    CU_ASSERT_EQUAL(tab->colunas, 5);
        3:   40:    CU_ASSERT_EQUAL(tab->grelha[0][0], 'e');
        3:   41:    CU_ASSERT_EQUAL(tab->grelha[1][1], 'c');
        3:   42:    CU_ASSERT_EQUAL(tab->grelha[2][2], 'd');
        3:   43:    CU_ASSERT_EQUAL(tab->grelha[3][3], 'e');
        3:   44:    CU_ASSERT_EQUAL(tab->grelha[4][4], 'b');
        -:   45:
        -:   46:    // Libera a memória alocada para o tabuleiro e pilha
        3:   47:    freeTabuleiro(tab);
        3:   48:    freePilha(&pilha);
        -:   49:}
        -:   50:
        -:   51:
        3:   52:void test_inicializarPilha(void) {
        3:   53:    Pilha pilha;
        3:   54:    inicializarPilha(&pilha, 5);
        3:   55:    CU_ASSERT_PTR_NOT_NULL(pilha.jogadas);
        3:   56:    CU_ASSERT_EQUAL(pilha.topo, -1);
        3:   57:    CU_ASSERT_EQUAL(pilha.capacidade, 5);
        -:   58:
        -:   59:    // Libera a memória alocada para a pilha
        3:   60:    freePilha(&pilha);
        3:   61:}
        -:   62:
        -:   63:
        3:   64:void test_freeTabuleiro(void) {
        -:   65:    // Aloca e inicializa o tabuleiro
        3:   66:    Tabuleiro* tab = (Tabuleiro*)malloc(sizeof(Tabuleiro));
        3:   67:    tab->linhas = 5;
        3:   68:    tab->colunas = 5;
        3:   69:    tab->grelha = (char**)malloc((size_t)tab->linhas * sizeof(char*));
        -:   70:
       18:   71:    for (int i = 0; i < tab->linhas; i++) {
       15:   72:        tab->grelha[i] = (char*)malloc((size_t)tab->colunas * sizeof(char));
        -:   73:    }
        -:   74:
        -:   75:    // Preenche a grelha com valores de exemplo
        3:   76:    tab->grelha[0][0] = 'A';
        3:   77:    tab->grelha[4][4] = 'B';
        -:   78:
        -:   79:    // Libera o tabuleiro
        3:   80:    freeTabuleiro(tab);
        -:   81:
        3:   82:}
        -:   83:
        -:   84:
        3:   85:void test_freePilha(void) {
        3:   86:    Pilha pilha;
        3:   87:    inicializarPilha(&pilha, 1);  // Aloca a pilha
        -:   88:
        -:   89:    // Realize as operações necessárias no teste...
        -:   90:    
        -:   91:    // Verifique se a pilha está sendo limpa corretamente
        3:   92:    freePilha(&pilha); // Libere a memória da pilha
        3:   93:}
        -:   94:
        -:   95:
        -:   96:
        3:   97:void test_redimensionarPilha(void) {
        3:   98:    Pilha pilha;
        3:   99:    inicializarPilha(&pilha, 2);
        3:  100:    pilha.topo = 1; // Simulando que a pilha está cheia
        -:  101:
        3:  102:    redimensionarPilha(&pilha);
        3:  103:    CU_ASSERT_EQUAL(pilha.capacidade, 4); // Verifica se a capacidade foi dobrada
        -:  104:
        3:  105:    freePilha(&pilha);
        3:  106:}
        -:  107:
        3:  108:void test_empurrarPilha(void) {
        3:  109:    Pilha pilha;
        3:  110:    inicializarPilha(&pilha, 2);
        -:  111:
        3:  112:    empurrarPilha(&pilha, 0, 0, 'a', 'b');
        3:  113:    CU_ASSERT_EQUAL(pilha.topo, 0);
        3:  114:    CU_ASSERT_EQUAL(pilha.jogadas[0].lin, 0);
        3:  115:    CU_ASSERT_EQUAL(pilha.jogadas[0].col, 0);
        3:  116:    CU_ASSERT_EQUAL(pilha.jogadas[0].anterior, 'a');
        3:  117:    CU_ASSERT_EQUAL(pilha.jogadas[0].tipo, 'b');
        -:  118:
        3:  119:    freePilha(&pilha);
        3:  120:}
        -:  121:
        -:  122:
        3:  123:void test_guardar(void) {
        3:  124:    Pilha pilha;
        3:  125:    inicializarPilha(&pilha, 10);
        -:  126:
        -:  127:    // Realizar operações no jogo aqui...
        -:  128:
        -:  129:    // Após o uso, liberar a memória
        3:  130:    freePilha(&pilha);
        3:  131:}
        -:  132:
        -:  133:
        -:  134:
        3:  135:void test_verificarRisca(void) {
        3:  136:    Tabuleiro* tab = malloc(sizeof(Tabuleiro));
        3:  137:    tab->linhas = 2;
        3:  138:    tab->colunas = 2;
        3:  139:    tab->grelha = malloc(2 * sizeof(char*));
        3:  140:    tab->grelha[0] = malloc(2 * sizeof(char));
        3:  141:    tab->grelha[1] = malloc(2 * sizeof(char));
        3:  142:    tab->grelha[0][0] = '#';
        3:  143:    tab->grelha[0][1] = 'a';
        3:  144:    tab->grelha[1][0] = 'b';
        3:  145:    tab->grelha[1][1] = 'c';
        -:  146:
        3:  147:    int resultado = verificarRisca(tab, 0, 0, tab->grelha[0][0]); // Pass the missing argument
        3:  148:    CU_ASSERT_EQUAL(resultado, 1); // Deve retornar 1 pois a casa (0,0) é riscada
        -:  149:
        3:  150:    freeTabuleiro(tab);
        3:  151:}
        -:  152:
        3:  153:void test_verificaBranco(void){
        3:  154:    Tabuleiro* tab = malloc(sizeof(Tabuleiro));
        3:  155:    tab->linhas = 2;
        3:  156:    tab->colunas = 2;
        3:  157:    tab->grelha = malloc(2 * sizeof(char*));
        3:  158:    tab->grelha[0] = malloc(2 * sizeof(char));
        3:  159:    tab->grelha[1] = malloc(2 * sizeof(char));
        3:  160:    tab->grelha[0][0] = 'A';
        3:  161:    tab->grelha[0][1] = 'b';
        3:  162:    tab->grelha[1][0] = 'c';
        3:  163:    tab->grelha[1][1] = 'd';
        -:  164:
        3:  165:    int resultado = verificarBranco(tab, 0, 0, /*tab->grelha[0][0]*/ 1); // Pass the missing argument
        3:  166:    CU_ASSERT_EQUAL(resultado,0); // Deve retornar 0 pois a casa (0,0)   é branca
        -:  167:
        3:  168:    freeTabuleiro(tab);
        3:  169:}
        -:  170:
        -:  171:
        3:  172:void test_verifica(void){
        3:  173:    Tabuleiro* tab = malloc(sizeof(Tabuleiro));
        3:  174:    tab->linhas = 2;
        3:  175:    tab->colunas = 2;
        3:  176:    tab->grelha = malloc(2 * sizeof(char*));
        3:  177:    tab->grelha[0] = malloc(2 * sizeof(char));
        3:  178:    tab->grelha[1] = malloc(2 * sizeof(char));
        3:  179:    tab->grelha[0][0] = 'A';
        3:  180:    tab->grelha[0][1] = 'B';
        3:  181:    tab->grelha[1][0] = 'C';
        3:  182:    tab->grelha[1][1] = 'D';
        -:  183:
        3:  184:    int resultado = verifica(tab, 0); // Pass the missing argument
        3:  185:    CU_ASSERT_EQUAL(resultado, 0); // Deve retornar 0 pois o tabuleiro está correto
        -:  186:
        3:  187:    freeTabuleiro(tab);
        3:  188:}
        -:  189:
        3:  190:void test_ler(void) {
        3:  191:    Tabuleiro* tab = malloc(sizeof(Tabuleiro));
        3:  192:    tab->linhas = 2;
        3:  193:    tab->colunas = 2;
        3:  194:    tab->grelha = malloc(2 * sizeof(char*));
        3:  195:    tab->grelha[0] = malloc(2 * sizeof(char));
        3:  196:    tab->grelha[1] = malloc(2 * sizeof(char));
        3:  197:    tab->grelha[0][0] = 'x';
        3:  198:    tab->grelha[0][1] = 'y';
        3:  199:    tab->grelha[1][0] = 'z';
        3:  200:    tab->grelha[1][1] = 'w';
        -:  201:
       3*:  202:    FILE* buffer = freopen("output.txt", "w", stdout);
        3:  203:    CU_ASSERT_PTR_NOT_NULL(buffer);
        3:  204:    ler(tab);
        3:  205:    fflush(stdout);
        -:  206:
       3*:  207:    if (freopen("/dev/tty", "w", stdout) == NULL) {
    #####:  208:        perror("freopen failed");
    #####:  209:        exit(EXIT_FAILURE);
        -:  210:    }
        -:  211:
        3:  212:    FILE* f = fopen("output.txt", "r");
        3:  213:    CU_ASSERT_PTR_NOT_NULL(f);
        -:  214:
        3:  215:    char linha[100];
       6*:  216:    CU_ASSERT_PTR_NOT_NULL(fgets(linha, sizeof(linha), f));
        3:  217:    CU_ASSERT_STRING_EQUAL(linha, "    a b \n");
        -:  218:
       6*:  219:    CU_ASSERT_PTR_NOT_NULL(fgets(linha, sizeof(linha), f));
        3:  220:    CU_ASSERT_STRING_EQUAL(linha, "    ---\n");
        -:  221:
       6*:  222:    CU_ASSERT_PTR_NOT_NULL(fgets(linha, sizeof(linha), f));
        3:  223:    CU_ASSERT_STRING_EQUAL(linha, " 1| x y \n");
        -:  224:
       6*:  225:    CU_ASSERT_PTR_NOT_NULL(fgets(linha, sizeof(linha), f));
        3:  226:    CU_ASSERT_STRING_EQUAL(linha, " 2| z w \n");
        -:  227:
       3*:  228:    fclose(f);
        3:  229:    freeTabuleiro(tab);
        3:  230:}
        -:  231:
        3:  232:void test_branco(void) {
        3:  233:    Tabuleiro* tab = malloc(sizeof(Tabuleiro));
        3:  234:    tab->linhas = 1;
        3:  235:    tab->colunas = 1;
        3:  236:    tab->grelha = malloc(sizeof(char*));
        3:  237:    tab->grelha[0] = malloc(sizeof(char));
        3:  238:    tab->grelha[0][0] = 'a';
        -:  239:
        3:  240:    Pilha pilha;
        3:  241:    inicializarPilha(&pilha, 10);
        -:  242:
        3:  243:    branco(tab, 0, 0, &pilha);
        3:  244:    CU_ASSERT_EQUAL(tab->grelha[0][0], 'A');
        -:  245:
        3:  246:    tab->grelha[0][0] = '#';
        3:  247:    branco(tab, 0, 0, &pilha);
        3:  248:    CU_ASSERT_EQUAL(tab->grelha[0][0], '#'); // Não deve alterar
        -:  249:
        3:  250:    freeTabuleiro(tab);
        3:  251:    freePilha(&pilha);
        3:  252:}
        -:  253:
        3:  254:void test_riscar(void) {
        3:  255:    Tabuleiro* tab = malloc(sizeof(Tabuleiro));
        3:  256:    tab->linhas = 1;
        3:  257:    tab->colunas = 1;
        3:  258:    tab->grelha = malloc(sizeof(char*));
        3:  259:    tab->grelha[0] = malloc(sizeof(char));
        3:  260:    tab->grelha[0][0] = 'a';
        -:  261:
        3:  262:    Pilha pilha;
        3:  263:    inicializarPilha(&pilha, 10);
        -:  264:
        3:  265:    riscar(tab, 0, 0, &pilha);
        3:  266:    CU_ASSERT_EQUAL(tab->grelha[0][0], '#');
        -:  267:
        3:  268:    tab->grelha[0][0] = 'A';
        3:  269:    riscar(tab, 0, 0, &pilha);
        3:  270:    CU_ASSERT_EQUAL(tab->grelha[0][0], 'A'); // ← Correto conforme lógica atual
        -:  271:    
        -:  272:
        3:  273:    freeTabuleiro(tab);
        3:  274:    freePilha(&pilha);
        3:  275:}
        -:  276:
        -:  277:
        3:  278:void test_ajudar(void) {
        -:  279:    // Setup: Criar o tabuleiro com 5x5
        3:  280:    Tabuleiro* tab = malloc(sizeof(Tabuleiro));
        3:  281:    tab->linhas = 5;
        3:  282:    tab->colunas = 5;
        3:  283:    tab->grelha = malloc(5 * sizeof(char*));
       18:  284:    for (int i = 0; i < 5; i++) {
       15:  285:        tab->grelha[i] = malloc(5 * sizeof(char));
       90:  286:        for (int j = 0; j < 5; j++) {
       75:  287:            tab->grelha[i][j] = (char)('a' + (i + j) % 26); // Preencher com letras aleatórias
        -:  288:        }
        -:  289:    }
        -:  290:
        -:  291:    // Criar algumas condições específicas
        3:  292:    tab->grelha[0][0] = 'A'; // Letra branca
        3:  293:    tab->grelha[1][0] = 'a'; // Letra minúscula que deve ser riscada
        3:  294:    tab->grelha[0][1] = 'B'; // Letra que será pintada de branco
        3:  295:    tab->grelha[2][2] = 'C'; // Outra letra maiúscula
        3:  296:    tab->grelha[3][3] = 'c'; // Outra letra minúscula
        3:  297:    tab->grelha[4][4] = '#'; // Casa riscada que deve pintar vizinhos
        -:  298:
        -:  299:    // Testar casas vazias adjacentes a duas ou mais letras brancas
        3:  300:    tab->grelha[1][1] = 'x'; // ou qualquer letra minúscula
        3:  301:    tab->grelha[2][1] = 'A'; // Letra branca adjacente
        3:  302:    tab->grelha[1][2] = 'A'; // Letra branca adjacente
        3:  303:    tab->grelha[4][3] = 'a'; // ← necessário para que a função branco pinte de branco
        -:  304:
        -:  305:
        -:  306:    // Inicializar pilha e contador
        3:  307:    Pilha pilha;
        3:  308:    inicializarPilha(&pilha, 10);
        3:  309:    int cont = 0;
        -:  310:
        -:  311:    // Chamar a função a ser testada
        3:  312:    ajudar(tab, &pilha, &cont);
        -:  313:
        -:  314:    // Teste 1: Verificar se a letra minúscula foi riscada
        3:  315:    CU_ASSERT_EQUAL(tab->grelha[1][0], '#'); // Letra 'a' deve ser riscada
        -:  316:
        -:  317:    // Teste 3: Verificar se a casa vizinha foi pintada de branco após a riscação
        3:  318:    CU_ASSERT_EQUAL(tab->grelha[0][1], 'B'); // A casa vizinha à 'A' deve ser pintada de branco
        -:  319:
        -:  320:    // Teste 4: Verificar se as casas vizinhas a uma casa riscada (#) foram pintadas de branco
        3:  321:    CU_ASSERT_EQUAL(tab->grelha[4][3], 'A'); // A casa acima de '#' (4,3) deve ser branca (A)
        -:  322:
        -:  323:    // Teste 5: Verificar se o contador foi incrementado
        3:  324:    CU_ASSERT_EQUAL(cont, 1); // O contador deve ser 1 pois houve modificações
        -:  325:
        -:  326:    // Liberação de memória
        3:  327:    freeTabuleiro(tab);
        3:  328:    freePilha(&pilha);
        3:  329:}
        -:  330:
        -:  331:
        -:  332:
        -:  333:
        3:  334:void test_verificaConectividade(void) {
        3:  335:    Tabuleiro* tab = malloc(sizeof(Tabuleiro));
        3:  336:    tab->linhas = 3;
        3:  337:    tab->colunas = 3;
        3:  338:    tab->grelha = malloc(3 * sizeof(char*));
       12:  339:    for (int i = 0; i < 3; i++) {
        9:  340:        tab->grelha[i] = malloc(3 * sizeof(char));
       36:  341:        for (int j = 0; j < 3; j++) {
       27:  342:            tab->grelha[i][j] = '.'; // Espaços vazios
        -:  343:        }
        -:  344:    }
        -:  345:
        -:  346:    // Primeiro cenário: casas brancas desconectadas
        3:  347:    tab->grelha[0][0] = 'A'; // Casa branca 1
        3:  348:    tab->grelha[2][2] = 'B'; // Casa branca 2, isolada
        -:  349:
        3:  350:    int resultado = verificaConectividade(tab, 1);
        3:  351:    CU_ASSERT_EQUAL(resultado, 1); // Deve retornar 1 (desconectado)
        -:  352:
        -:  353:    // Segundo cenário: todas casas brancas conectadas
        3:  354:    tab->grelha[0][1] = 'C';
        3:  355:    tab->grelha[1][1] = 'D';
        3:  356:    tab->grelha[2][1] = 'E';
        -:  357:
        3:  358:    resultado = verificaConectividade(tab, 1); // Pass the missing argument
        3:  359:    CU_ASSERT_EQUAL(resultado, 0); // Deve retornar 0 (todas conectadas)
        -:  360:
        3:  361:    freeTabuleiro(tab);
        3:  362:}
        -:  363:
        -:  364:
        3:  365:void test_dfs(void) {
        3:  366:    Tabuleiro* tab = malloc(sizeof(Tabuleiro));
        3:  367:    tab->linhas = 3;
        3:  368:    tab->colunas = 3;
        3:  369:    tab->grelha = malloc(3 * sizeof(char*));
       12:  370:    for (int i = 0; i < 3; i++) {
        9:  371:        tab->grelha[i] = malloc(3 * sizeof(char));
       36:  372:        for (int j = 0; j < 3; j++) {
       27:  373:            tab->grelha[i][j] = 'A'; // Preencher com letras brancas
        -:  374:        }
        -:  375:    }
        -:  376:
        3:  377:    int visitado[3][3] = {0}; // Inicializa a matriz de visitados
        -:  378:
        3:  379:    dfs(tab, 0, 0, visitado); // Chama a função DFS
        -:  380:
        -:  381:    // Verifica se todas as casas foram visitadas
       12:  382:    for (int i = 0; i < 3; i++) {
       36:  383:        for (int j = 0; j < 3; j++) {
       27:  384:            CU_ASSERT_EQUAL(visitado[i][j], 1); // Todas as casas devem ser visitadas
        -:  385:        }
        -:  386:    }
        -:  387:
        -:  388:    // Liberação de memória
        3:  389:    freeTabuleiro(tab);
        3:  390:}
        -:  391:
        -:  392:
        -:  393:
        3:  394:void test_verificaBranco2(void) {
        3:  395:    Tabuleiro* tab = malloc(sizeof(Tabuleiro));
        3:  396:    tab->linhas = 2;
        3:  397:    tab->colunas = 2;
        3:  398:    tab->grelha = malloc(2 * sizeof(char*));
        3:  399:    tab->grelha[0] = malloc(2 * sizeof(char));
        3:  400:    tab->grelha[1] = malloc(2 * sizeof(char));
        3:  401:    tab->grelha[0][0] = 'A';
        3:  402:    tab->grelha[0][1] = 'B';
        3:  403:    tab->grelha[1][0] = 'C';
        3:  404:    tab->grelha[1][1] = 'D';
        -:  405:
        3:  406:    int resultado = verificaBranco2(tab); // Pass the missing argument
        3:  407:    CU_ASSERT_EQUAL(resultado, 0); // Deve retornar 0 pois não há brancos duplicados
        -:  408:
        3:  409:    freeTabuleiro(tab);
        3:  410:}
        -:  411:
        -:  412:
        -:  413:
        -:  414:
        3:  415:void test_desfazer(void){
        3:  416:    Tabuleiro* tab = malloc(sizeof(Tabuleiro));
        3:  417:    tab->linhas = 1;
        3:  418:    tab->colunas = 1;
        3:  419:    tab->grelha = malloc(sizeof(char*));
        3:  420:    tab->grelha[0] = malloc(sizeof(char));
        3:  421:    tab->grelha[0][0] = 'a';
        -:  422:
        3:  423:    Pilha pilha;
        3:  424:    inicializarPilha(&pilha, 10);
        -:  425:
        3:  426:    empurrarPilha(&pilha, 0, 0, 'a', 'b');
        3:  427:    desfazer(tab, &pilha);
        3:  428:    CU_ASSERT_EQUAL(tab->grelha[0][0], 'a');
        -:  429:
        3:  430:    freeTabuleiro(tab);
        3:  431:    freePilha(&pilha);
        3:  432:}
        -:  433:
        -:  434:
        -:  435:
        -:  436:
        -:  437:// void testresolver(void) 
        -:  438:
        -:  439:
        3:  440:int main() {
        3:  441:    if (CUE_SUCCESS != CU_initialize_registry())
    #####:  442:        return CU_get_error();
        -:  443:
        3:  444:    CU_pSuite suite = CU_add_suite("Teste do jogo", NULL, NULL);
        3:  445:    if (suite == NULL) {
    #####:  446:        CU_cleanup_registry();
    #####:  447:        return CU_get_error();
        -:  448:    }
        -:  449:
        3:  450:    CU_add_test(suite, "test_carregar", test_carregar);
        3:  451:    CU_add_test(suite, "test_ler", test_ler);
        3:  452:    CU_add_test(suite, "test_branco", test_branco);
        3:  453:    CU_add_test(suite, "test_riscar", test_riscar);
        3:  454:    CU_add_test(suite, "test_ajudar", test_ajudar);
        -:  455:    // CU_add_test(suite,"test_resolver", test_resolver);
        3:  456:    CU_add_test(suite,"test_desfazer", test_desfazer);
        3:  457:    CU_add_test(suite, "test_freeTabuleiro", test_freeTabuleiro);
        3:  458:    CU_add_test(suite, "test_freePilha", test_freePilha);
        3:  459:    CU_add_test(suite, "test_empurrarPilha", test_empurrarPilha);
        3:  460:    CU_add_test(suite, "test_redimensionarPilha", test_redimensionarPilha);
        3:  461:    CU_add_test(suite, "test_guardar", test_guardar);
        3:  462:    CU_add_test(suite, "test_verificarRisca", test_verificarRisca);
        3:  463:    CU_add_test(suite, "test_verificaBranco", test_verificaBranco);
        3:  464:    CU_add_test(suite, "test_verifica", test_verifica);
        3:  465:    CU_add_test(suite, "test_inicializarPilha", test_inicializarPilha);
        3:  466:    CU_add_test(suite, "test_verificaConectividade", test_verificaConectividade);
        3:  467:    CU_add_test(suite, "test_dfs", test_dfs);
        3:  468:    CU_add_test(suite, "test_verificaBranco2", test_verificaBranco2);
        -:  469:
        -:  470:
        3:  471:    CU_basic_set_mode(CU_BRM_VERBOSE);
        3:  472:    CU_basic_run_tests();
        3:  473:    CU_cleanup_registry();
        3:  474:    return CU_get_error();
        -:  475:}
