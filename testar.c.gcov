        -:    0:Source:src/testar.c
        -:    0:Graph:src/testar.gcno
        -:    0:Data:src/testar.gcda
        -:    0:Runs:5
        -:    1:#include <CUnit/CUnit.h>
        -:    2:#include <CUnit/Basic.h>
        -:    3:#include <stdio.h>
        -:    4:#include <stdlib.h>
        -:    5:#include <string.h>
        -:    6:#include "jogo.h"
        -:    7:
        5:    8:void criar_ficheiro_teste(const char* nome_ficheiro) {
        5:    9:    FILE* f = fopen(nome_ficheiro, "w");
       5*:   10:    fprintf(f, "5 5\n");
       5*:   11:    fprintf(f, "ecadc\n");
       5*:   12:    fprintf(f, "dcdec\n");
       5*:   13:    fprintf(f, "bddce\n");
       5*:   14:    fprintf(f, "cdeeb\n");
       5*:   15:    fprintf(f, "accbb\n");
        5:   16:}
        -:   17:
        5:   18:void test_carregar(void) {
        5:   19:    criar_ficheiro_teste("tabuleiro.txt");
        -:   20:
        -:   21:    // Inicializando a pilha
        5:   22:    Pilha pilha;
        5:   23:    inicializarPilha(&pilha, 10);
        -:   24:
        -:   25:    // Carregando o tabuleiro
        5:   26:    Tabuleiro* tab = carregar("tabuleiro.txt", &pilha);
        -:   27:
        -:   28:    // Verifique se o tabuleiro não é NULL
        5:   29:    if (tab == NULL) {
        5:   30:        CU_FAIL("Falha ao carregar o tabuleiro");
        5:   31:        freePilha(&pilha);  // Libera a pilha caso o carregamento falhe
        5:   32:        return;  // Interrompe o teste se o tabuleiro for NULL
        -:   33:    }
        -:   34:
        -:   35:    // Realiza os asserts para validar os dados carregados
    #####:   36:    CU_ASSERT_PTR_NOT_NULL(tab);
    #####:   37:    CU_ASSERT_EQUAL(tab->linhas, 5);
    #####:   38:    CU_ASSERT_EQUAL(tab->colunas, 5);
    #####:   39:    CU_ASSERT_EQUAL(tab->grelha[0][0], 'E');
    #####:   40:    CU_ASSERT_EQUAL(tab->grelha[1][1], '#');
    #####:   41:    CU_ASSERT_EQUAL(tab->grelha[2][2], 'd');
    #####:   42:    CU_ASSERT_EQUAL(tab->grelha[3][3], 'e');
    #####:   43:    CU_ASSERT_EQUAL(tab->grelha[4][4], 'b');
        -:   44:
        -:   45:    // Libera a memória alocada para o tabuleiro e pilha
    #####:   46:    freeTabuleiro(tab);
    #####:   47:    freePilha(&pilha);
        -:   48:}
        -:   49:
        -:   50:
        5:   51:void test_inicializarPilha(void) {
        5:   52:    Pilha pilha;
        5:   53:    inicializarPilha(&pilha, 5);
        5:   54:    CU_ASSERT_PTR_NOT_NULL(pilha.jogadas);
        5:   55:    CU_ASSERT_EQUAL(pilha.topo, -1);
        5:   56:    CU_ASSERT_EQUAL(pilha.capacidade, 5);
        -:   57:
        -:   58:    // Libera a memória alocada para a pilha
        5:   59:    freePilha(&pilha);
        5:   60:}
        -:   61:
        -:   62:
        5:   63:void test_freeTabuleiro(void) {
        -:   64:    // Aloca e inicializa o tabuleiro
        5:   65:    Tabuleiro* tab = (Tabuleiro*)malloc(sizeof(Tabuleiro));
        5:   66:    tab->linhas = 5;
        5:   67:    tab->colunas = 5;
        5:   68:    tab->grelha = (char**)malloc(tab->linhas * sizeof(char*));
        -:   69:
       30:   70:    for (int i = 0; i < tab->linhas; i++) {
       25:   71:        tab->grelha[i] = (char*)malloc(tab->colunas * sizeof(char));
        -:   72:    }
        -:   73:
        -:   74:    // Preenche a grelha com valores de exemplo
        5:   75:    tab->grelha[0][0] = 'A';
        5:   76:    tab->grelha[4][4] = 'B';
        -:   77:
        -:   78:    // Libera o tabuleiro
        5:   79:    freeTabuleiro(tab);
        -:   80:
        5:   81:}
        -:   82:
        -:   83:
        5:   84:void test_freePilha(void) {
        5:   85:    Pilha pilha;
        5:   86:    inicializarPilha(&pilha, 1);  // Aloca a pilha
        -:   87:
        -:   88:    // Realize as operações necessárias no teste...
        -:   89:    
        -:   90:    // Verifique se a pilha está sendo limpa corretamente
        5:   91:    freePilha(&pilha); // Libere a memória da pilha
        5:   92:}
        -:   93:
        -:   94:
        -:   95:
        5:   96:void test_redimensionarPilha(void) {
        5:   97:    Pilha pilha;
        5:   98:    inicializarPilha(&pilha, 2);
        5:   99:    pilha.topo = 1; // Simulando que a pilha está cheia
        -:  100:
        5:  101:    redimensionarPilha(&pilha);
        5:  102:    CU_ASSERT_EQUAL(pilha.capacidade, 4); // Verifica se a capacidade foi dobrada
        -:  103:
        5:  104:    freePilha(&pilha);
        5:  105:}
        -:  106:
        5:  107:void test_empurrarPilha(void) {
        5:  108:    Pilha pilha;
        5:  109:    inicializarPilha(&pilha, 2);
        -:  110:
        5:  111:    empurrarPilha(&pilha, 0, 0, 'a', 'b');
        5:  112:    CU_ASSERT_EQUAL(pilha.topo, 0);
        5:  113:    CU_ASSERT_EQUAL(pilha.jogadas[0].lin, 0);
        5:  114:    CU_ASSERT_EQUAL(pilha.jogadas[0].col, 0);
        5:  115:    CU_ASSERT_EQUAL(pilha.jogadas[0].anterior, 'a');
        5:  116:    CU_ASSERT_EQUAL(pilha.jogadas[0].tipo, 'b');
        -:  117:
        5:  118:    freePilha(&pilha);
        5:  119:}
        -:  120:
        -:  121:
        5:  122:void test_guardar(void) {
        5:  123:    Pilha pilha;
        5:  124:    inicializarPilha(&pilha, 10);
        -:  125:
        -:  126:    // Realizar operações no jogo aqui...
        -:  127:
        -:  128:    // Após o uso, liberar a memória
        5:  129:    freePilha(&pilha);
        5:  130:}
        -:  131:
        -:  132:
        -:  133:
        5:  134:void test_verificarRisca(void) {
        5:  135:    Tabuleiro* tab = malloc(sizeof(Tabuleiro));
        5:  136:    tab->linhas = 2;
        5:  137:    tab->colunas = 2;
        5:  138:    tab->grelha = malloc(2 * sizeof(char*));
        5:  139:    tab->grelha[0] = malloc(2 * sizeof(char));
        5:  140:    tab->grelha[1] = malloc(2 * sizeof(char));
        5:  141:    tab->grelha[0][0] = '#';
        5:  142:    tab->grelha[0][1] = 'a';
        5:  143:    tab->grelha[1][0] = 'b';
        5:  144:    tab->grelha[1][1] = 'c';
        -:  145:
        5:  146:    int resultado = verificarRisca(tab, 0, 0);
        5:  147:    CU_ASSERT_EQUAL(resultado, 1); // Deve retornar 1 pois a casa (0,0) é riscada
        -:  148:
        5:  149:    freeTabuleiro(tab);
        5:  150:}
        -:  151:
        5:  152:void test_verificaBranco(void){
        5:  153:    Tabuleiro* tab = malloc(sizeof(Tabuleiro));
        5:  154:    tab->linhas = 2;
        5:  155:    tab->colunas = 2;
        5:  156:    tab->grelha = malloc(2 * sizeof(char*));
        5:  157:    tab->grelha[0] = malloc(2 * sizeof(char));
        5:  158:    tab->grelha[1] = malloc(2 * sizeof(char));
        5:  159:    tab->grelha[0][0] = 'A';
        5:  160:    tab->grelha[0][1] = 'B';
        5:  161:    tab->grelha[1][0] = 'C';
        5:  162:    tab->grelha[1][1] = 'D';
        -:  163:
        5:  164:    int resultado = verificarBranco(tab, 0, 0);
        5:  165:    CU_ASSERT_EQUAL(resultado, 1); // Deve retornar 1 pois a casa (0,0) é branca
        -:  166:
        5:  167:    freeTabuleiro(tab);
        5:  168:}
        -:  169:
        -:  170:
        5:  171:void test_verifica(void){
        5:  172:    Tabuleiro* tab = malloc(sizeof(Tabuleiro));
        5:  173:    tab->linhas = 2;
        5:  174:    tab->colunas = 2;
        5:  175:    tab->grelha = malloc(2 * sizeof(char*));
        5:  176:    tab->grelha[0] = malloc(2 * sizeof(char));
        5:  177:    tab->grelha[1] = malloc(2 * sizeof(char));
        5:  178:    tab->grelha[0][0] = 'A';
        5:  179:    tab->grelha[0][1] = 'B';
        5:  180:    tab->grelha[1][0] = 'C';
        5:  181:    tab->grelha[1][1] = 'D';
        -:  182:
        5:  183:    int resultado = verifica(tab);
        5:  184:    CU_ASSERT_EQUAL(resultado, 0); // Deve retornar 0 pois o tabuleiro está correto
        -:  185:
        5:  186:    freeTabuleiro(tab);
        5:  187:}
        -:  188:
        5:  189:void test_ler(void) {
        5:  190:    Tabuleiro* tab = malloc(sizeof(Tabuleiro));
        5:  191:    tab->linhas = 2;
        5:  192:    tab->colunas = 2;
        5:  193:    tab->grelha = malloc(2 * sizeof(char*));
        5:  194:    tab->grelha[0] = malloc(2 * sizeof(char));
        5:  195:    tab->grelha[1] = malloc(2 * sizeof(char));
        5:  196:    tab->grelha[0][0] = 'x';
        5:  197:    tab->grelha[0][1] = 'y';
        5:  198:    tab->grelha[1][0] = 'z';
        5:  199:    tab->grelha[1][1] = 'w';
        -:  200:
       5*:  201:    FILE* buffer = freopen("output.txt", "w", stdout);
        5:  202:    CU_ASSERT_PTR_NOT_NULL(buffer);
        5:  203:    ler(tab);
        5:  204:    fflush(stdout);
        -:  205:
       5*:  206:    if (freopen("/dev/tty", "w", stdout) == NULL) {
    #####:  207:        perror("freopen failed");
    #####:  208:        exit(EXIT_FAILURE);
        -:  209:    }
        -:  210:
        5:  211:    FILE* f = fopen("output.txt", "r");
        5:  212:    CU_ASSERT_PTR_NOT_NULL(f);
        -:  213:
        5:  214:    char linha[100];
      10*:  215:    CU_ASSERT_PTR_NOT_NULL(fgets(linha, sizeof(linha), f));
        5:  216:    CU_ASSERT_STRING_EQUAL(linha, "    a b \n");
        -:  217:
      10*:  218:    CU_ASSERT_PTR_NOT_NULL(fgets(linha, sizeof(linha), f));
        5:  219:    CU_ASSERT_STRING_EQUAL(linha, "    --\n");
        -:  220:
      10*:  221:    CU_ASSERT_PTR_NOT_NULL(fgets(linha, sizeof(linha), f));
        5:  222:    CU_ASSERT_STRING_EQUAL(linha, " 1| x y \n");
        -:  223:
      10*:  224:    CU_ASSERT_PTR_NOT_NULL(fgets(linha, sizeof(linha), f));
        5:  225:    CU_ASSERT_STRING_EQUAL(linha, " 2| z w \n");
        -:  226:
       5*:  227:    fclose(f);
        5:  228:    freeTabuleiro(tab);
        5:  229:}
        -:  230:
        5:  231:void test_branco(void) {
        5:  232:    Tabuleiro* tab = malloc(sizeof(Tabuleiro));
        5:  233:    tab->linhas = 1;
        5:  234:    tab->colunas = 1;
        5:  235:    tab->grelha = malloc(sizeof(char*));
        5:  236:    tab->grelha[0] = malloc(sizeof(char));
        5:  237:    tab->grelha[0][0] = 'a';
        -:  238:
        5:  239:    Pilha pilha;
        5:  240:    inicializarPilha(&pilha, 10);
        -:  241:
        5:  242:    branco(tab, 0, 0, &pilha);
        5:  243:    CU_ASSERT_EQUAL(tab->grelha[0][0], 'A');
        -:  244:
        5:  245:    tab->grelha[0][0] = '#';
        5:  246:    branco(tab, 0, 0, &pilha);
        5:  247:    CU_ASSERT_EQUAL(tab->grelha[0][0], '#'); // Não deve alterar
        -:  248:
        5:  249:    freeTabuleiro(tab);
        5:  250:    freePilha(&pilha);
        5:  251:}
        -:  252:
        5:  253:void test_riscar(void) {
        5:  254:    Tabuleiro* tab = malloc(sizeof(Tabuleiro));
        5:  255:    tab->linhas = 1;
        5:  256:    tab->colunas = 1;
        5:  257:    tab->grelha = malloc(sizeof(char*));
        5:  258:    tab->grelha[0] = malloc(sizeof(char));
        5:  259:    tab->grelha[0][0] = 'a';
        -:  260:
        5:  261:    Pilha pilha;
        5:  262:    inicializarPilha(&pilha, 10);
        -:  263:
        5:  264:    riscar(tab, 0, 0, &pilha);
        5:  265:    CU_ASSERT_EQUAL(tab->grelha[0][0], '#');
        -:  266:
        5:  267:    tab->grelha[0][0] = 'A';
        5:  268:    riscar(tab, 0, 0, &pilha);
        5:  269:    CU_ASSERT_EQUAL(tab->grelha[0][0], 'A'); // Não deve alterar
        -:  270:
        5:  271:    freeTabuleiro(tab);
        5:  272:    freePilha(&pilha);
        5:  273:}
        -:  274:
        5:  275:void test_ajudar(void) {
        -:  276:    // Setup: Criar o tabuleiro com 5x5
        5:  277:    Tabuleiro* tab = malloc(sizeof(Tabuleiro));
        5:  278:    tab->linhas = 5;
        5:  279:    tab->colunas = 5;
        5:  280:    tab->grelha = malloc(5 * sizeof(char*));
       30:  281:        for (int i = 0; i < 5; i++) {
       25:  282:            tab->grelha[i] = malloc(5 * sizeof(char));
      150:  283:            for (int j = 0; j < 5; j++) {
      125:  284:                tab->grelha[i][j] = (char)('a' + (i + j) % 26); // Preencher com letras aleatórias
        -:  285:            }
        -:  286:        }
        -:  287:    
        -:  288:
        -:  289:    // Criar algumas condições específicas
        5:  290:    tab->grelha[0][0] = 'A'; // Letra branca
        5:  291:    tab->grelha[1][0] = 'a'; // Letra minúscula que deve ser riscada
        5:  292:    tab->grelha[0][1] = 'B'; // Letra que será pintada de branco
        5:  293:    tab->grelha[2][2] = 'C'; // Outra letra maiúscula
        5:  294:    tab->grelha[3][3] = 'c'; // Outra letra minúscula
        5:  295:    tab->grelha[4][4] = '#'; // Casa riscada que deve pintar vizinhos
        -:  296:
        -:  297:    // Testar casas vazias adjacentes a duas ou mais letras brancas
        5:  298:    tab->grelha[1][1] = ' '; // Casa vazia
        5:  299:    tab->grelha[2][1] = 'A'; // Letra branca adjacente
        5:  300:    tab->grelha[1][2] = 'A'; // Letra branca adjacente
        -:  301:
        -:  302:    // Inicializar pilha e contador
        5:  303:    Pilha pilha;
        5:  304:    inicializarPilha(&pilha, 10);
        5:  305:    int cont = 0;
        -:  306:
        -:  307:    // Chamar a função a ser testada
        5:  308:    ajudar(tab, &pilha, &cont);
        -:  309:
        -:  310:    // Teste 1: Verificar se a letra minúscula foi riscada
        5:  311:    CU_ASSERT_EQUAL(tab->grelha[1][0], '#'); // Letra 'a' deve ser riscada
        -:  312:
        -:  313:    // Teste 2: Verificar se a casa vazia foi pintada de branco (deve ter 2 brancas adjacentes)
        5:  314:    CU_ASSERT_EQUAL(tab->grelha[1][1], 'A'); // A casa vazia deve ser pintada de branco
        -:  315:
        -:  316:    // Teste 3: Verificar se a casa vizinha foi pintada de branco após a riscação
        5:  317:    CU_ASSERT_EQUAL(tab->grelha[0][1], 'B'); // A casa vizinha à 'A' deve ser pintada de branco
        -:  318:
        -:  319:    // Teste 4: Verificar se as casas vizinhas a uma casa riscada (#) foram pintadas de branco
        5:  320:    CU_ASSERT_EQUAL(tab->grelha[4][3], 'A'); // A casa acima de '#' (4,3) deve ser branca (A)
        -:  321:
        -:  322:    // Teste 5: Verificar se o contador foi incrementado
        5:  323:    CU_ASSERT_EQUAL(cont, 1); // O contador deve ser 1 pois houve modificações
        -:  324:
        -:  325:    // Liberação de memória
        5:  326:    freeTabuleiro(tab);
        5:  327:    freePilha(&pilha);
        5:  328:}
        -:  329:
        -:  330:/*
        -:  331:void test_resolver(void) {
        -:  332:    Tabuleiro* tab = malloc(sizeof(Tabuleiro));
        -:  333:    tab->linhas = 5;
        -:  334:    tab->colunas = 5;
        -:  335:    tab->grelha = malloc((size_t)tab->linhas * sizeof(char*));
        -:  336:    for (int i = 0; i < tab->linhas; i++) {
        -:  337:        tab->grelha[i] = malloc((size_t)tab->colunas * sizeof(char));
        -:  338:        for (int j = 0; j < tab->colunas; j++) {
        -:  339:            tab->grelha[i][j] = (char)('a' + (rand() % 26)); // Gerar letras aleatórias entre 'a' e 'z'
        -:  340:        }
        -:  341:    }
        -:  342:    
        -:  343:
        -:  344:    // Inicializar pilha
        -:  345:    Pilha pilha;
        -:  346:    inicializarPilha(&pilha, 10);
        -:  347:
        -:  348:    // Chama a função a ser testada
        -:  349:    resolver(tab, &pilha);
        -:  350:
        -:  351:    // Testes: Verificar o estado final do tabuleiro após resolver
        -:  352:    // 1. Verifica se não há mais letras minúsculas no tabuleiro (deveriam ser riscadas ou pintadas)
        -:  353:    for (int i = 0; i < tab->linhas; i++) {
        -:  354:        for (int j = 0; j < tab->colunas; j++) {
        -:  355:            // A função deve riscar ou pintar as letras minúsculas. Não deve haver letras minúsculas ao final
        -:  356:            if (tab->grelha[i][j] >= 'a' && tab->grelha[i][j] <= 'z') {
        -:  357:                CU_FAIL("O tabuleiro contém letras minúsculas após a resolução.");
        -:  358:            }
        -:  359:        }
        -:  360:    }
        -:  361:
        -:  362:    // 2. Verifica se todas as letras minúsculas adjacentes a uma letra riscada (#) foram pintadas de branco (A-Z)
        -:  363:    for (int i = 0; i < tab->linhas; i++) {
        -:  364:        for (int j = 0; j < tab->colunas; j++) {
        -:  365:            if (tab->grelha[i][j] == '#') {
        -:  366:                int direcoes[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // cima, baixo, esquerda, direita
        -:  367:                for (int k = 0; k < 4; k++) {
        -:  368:                    int newLin = i + direcoes[k][0];
        -:  369:                    int newCol = j + direcoes[k][1];
        -:  370:                
        -:  371:                    if (newLin >= 0 && newLin < tab->linhas && newCol >= 0 && newCol < tab->colunas) {
        -:  372:                        // Verifica se uma letra adjacente a '#' (riscada) foi pintada de branco
        -:  373:                        if (tab->grelha[newLin][newCol] >= 'a' && tab->grelha[newLin][newCol] <= 'z') {
        -:  374:                            CU_ASSERT_EQUAL(tab->grelha[newLin][newCol], '#');
        -:  375:                        }
        -:  376:                    }
        -:  377:                }
        -:  378:            }
        -:  379:        }
        -:  380:    }
        -:  381:
        -:  382:    // 3. Verifica se as letras únicas foram corretamente identificadas (riscar ou pintar)
        -:  383:    for (int i = 0; i < tab->linhas; i++) {
        -:  384:        for (int j = 0; j < tab->colunas; j++) {
        -:  385:            char c = tab->grelha[i][j];
        -:  386:            if (c >= 'a' && c <= 'z') {
        -:  387:                // Se a letra é única, deveria ter sido riscada
        -:  388:                CU_ASSERT_EQUAL(tab->grelha[i][j], '#');
        -:  389:            }
        -:  390:        }
        -:  391:    }
        -:  392:
        -:  393:    // Libera memória
        -:  394:    freeTabuleiro(tab);
        -:  395:    freePilha(&pilha);
        -:  396:}
        -:  397:*/
        -:  398:
        5:  399:void test_desfazer(void){
        5:  400:    Tabuleiro* tab = malloc(sizeof(Tabuleiro));
        5:  401:    tab->linhas = 1;
        5:  402:    tab->colunas = 1;
        5:  403:    tab->grelha = malloc(sizeof(char*));
        5:  404:    tab->grelha[0] = malloc(sizeof(char));
        5:  405:    tab->grelha[0][0] = 'a';
        -:  406:
        5:  407:    Pilha pilha;
        5:  408:    inicializarPilha(&pilha, 10);
        -:  409:
        5:  410:    empurrarPilha(&pilha, 0, 0, 'a', 'b');
        5:  411:    desfazer(tab, &pilha);
        5:  412:    CU_ASSERT_EQUAL(tab->grelha[0][0], 'a');
        -:  413:
        5:  414:    freeTabuleiro(tab);
        5:  415:    freePilha(&pilha);
        5:  416:}
        -:  417:
        -:  418:
        -:  419:
        5:  420:int main() {
        5:  421:    if (CUE_SUCCESS != CU_initialize_registry())
    #####:  422:        return CU_get_error();
        -:  423:
        5:  424:    CU_pSuite suite = CU_add_suite("Teste do jogo", NULL, NULL);
        5:  425:    if (suite == NULL) {
    #####:  426:        CU_cleanup_registry();
    #####:  427:        return CU_get_error();
        -:  428:    }
        -:  429:
        5:  430:    CU_add_test(suite, "test_carregar", test_carregar);
        5:  431:    CU_add_test(suite, "test_ler", test_ler);
        5:  432:    CU_add_test(suite, "test_branco", test_branco);
        5:  433:    CU_add_test(suite, "test_riscar", test_riscar);
        5:  434:    CU_add_test(suite, "test_ajudar", test_ajudar);
        -:  435:    // CU_add_test(suite,"test_resolver", test_resolver);
        5:  436:    CU_add_test(suite,"test_desfazer", test_desfazer);
        5:  437:    CU_add_test(suite, "test_freeTabuleiro", test_freeTabuleiro);
        5:  438:    CU_add_test(suite, "test_freePilha", test_freePilha);
        5:  439:    CU_add_test(suite, "test_empurrarPilha", test_empurrarPilha);
        5:  440:    CU_add_test(suite, "test_redimensionarPilha", test_redimensionarPilha);
        5:  441:    CU_add_test(suite, "test_guardar", test_guardar);
        5:  442:    CU_add_test(suite, "test_verificarRisca", test_verificarRisca);
        5:  443:    CU_add_test(suite, "test_verificaBranco", test_verificaBranco);
        5:  444:    CU_add_test(suite, "test_verifica", test_verifica);
        5:  445:    CU_add_test(suite, "test_inicializarPilha", test_inicializarPilha);
        -:  446:
        -:  447:
        5:  448:    CU_basic_set_mode(CU_BRM_VERBOSE);
        5:  449:    CU_basic_run_tests();
        5:  450:    CU_cleanup_registry();
        5:  451:    return CU_get_error();
        -:  452:}
