        -:    0:Source:src/jogo.c
        -:    0:Source is newer than graph
        -:    1:#include "jogo.h"
        -:    2:
        -:    3:Tabuleiro* carregar(const char* ficheiro, Pilha* pilha) {
        -:    4:    FILE* f = fopen(ficheiro, "r");
        -:    5:    if (!f) {
        1:    6:        perror("Erro ao abrir ficheiro");
        1:    7:        return NULL;
        1:    8:    }
    #####:    9:    Tabuleiro* tab = malloc((size_t)sizeof(Tabuleiro));
    #####:   10:    if (!fscanf(f, "%d %d", &tab->linhas, &tab->colunas)) {
        -:   11:        printf("Erro ao ler o tamanho do tabuleiro\n");
        1:   12:        fclose(f);
        1:   13:        free(tab);
    #####:   14:        return NULL;
    #####:   15:    }
    #####:   16:    else if (tab->linhas <= 0 || tab->colunas <= 0 || tab->linhas != tab->colunas) {
    #####:   17:        printf("Tamanho inválido do tabuleiro\n");
        -:   18:        fclose(f);
       1*:   19:        free(tab);
        1:   20:        return NULL;
        1:   21:    }
        1:   22:
        1:   23:    tab->grelha = malloc((size_t)tab->linhas * sizeof(char*));
        -:   24:    for (int i = 0; i < tab->linhas; i++) {
        -:   25:        tab->grelha[i] = malloc((size_t)tab->colunas * sizeof(char));
    #####:   26:        for (int j = 0; j < tab->colunas; j++) {
    #####:   27:            if (fscanf(f, " %c", &tab->grelha[i][j]) != 1) {
    #####:   28:                printf("Erro ao ler o tabuleiro do ficheiro.\n");
    #####:   29:                fclose(f);
    #####:   30:                freeTabuleiro(tab);
    #####:   31:                return NULL;
    #####:   32:            }
    #####:   33:        }
    #####:   34:    }
        -:   35:
        -:   36:    // Ignorar separador "--"
        -:   37:    char linhaBuffer[100];
        -:   38:    while (fgets(linhaBuffer, sizeof(linhaBuffer), f)) {
        -:   39:        if (linhaBuffer[0] == '-' && linhaBuffer[1] == '-') break;
    #####:   40:    }
    #####:   41:
    #####:   42:    // Ler jogadas
        -:   43:    char tipo, coluna;
        -:   44:    int linha;
        -:   45:    while (fscanf(f, " %c %c %d", &tipo, &coluna, &linha) == 3) {
    #####:   46:        int lin = linha - 1;
    #####:   47:        int col = coluna - 'a';
    #####:   48:        if (lin >= 0 && lin < tab->linhas && col >= 0 && col < tab->colunas) {
    #####:   49:            char anterior = tab->grelha[lin][col];
    #####:   50:            empurrarPilha(pilha, lin, col, anterior, tipo);
    #####:   51:            tab->grelha[lin][col] = (tipo == 'b') ? (char)toupper((unsigned char)anterior) : '#';
    #####:   52:        }
    #####:   53:    }
    #####:   54:    fclose(f);
        -:   55:    return tab;
        -:   56:}
    #####:   57:
    #####:   58:void ler(Tabuleiro* tab) {
        -:   59:    printf("    ");
        -:   60:    for (int i = 0; i < tab->linhas; i++) {
        1:   61:        printf("%c ", i + 'a');
        1:   62:    }
        3:   63:    printf("\n    -");
        2:   64:    for (int i = 1; i < tab->linhas; i++) {
        -:   65:        printf("--");
        1:   66:    }
        2:   67:    printf("\n");
        1:   68:    for (int i = 0; i < tab->linhas; i++) {
        -:   69:        printf("%2d| ", i + 1);
        1:   70:        for (int j = 0; j < tab->colunas; j++) {
        3:   71:            printf("%c ", tab->grelha[i][j]);
        2:   72:        }
        6:   73:        printf("\n");
        4:   74:    }
        -:   75:}
        2:   76:
        -:   77:void branco(Tabuleiro* tab, int lin, int col, Pilha* pilha) { 
        1:   78:    if (lin >= 0 && lin < tab->linhas && col >= 0 && col < tab->colunas) {
        -:   79:        empurrarPilha(pilha, lin, col, tab->grelha[lin][col], 'b');
       12:   80:        tab->grelha[lin][col] = (char)toupper((unsigned char)tab->grelha[lin][col]);
       12:   81:    } else {
        4:   82:        printf("Posição inválida! Tente de novo.\n");
        -:   83:    }
        8:   84:}
        1:   85:void riscar(Tabuleiro* tab, int lin, int col, Pilha* pilha) {
        -:   86:    if (lin >= 0 && lin < tab->linhas && col >= 0 && col < tab->colunas) {
        7:   87:        empurrarPilha(pilha, lin, col, tab->grelha[lin][col], 'r');
        7:   88:        tab->grelha[lin][col] = '#';
        7:   89:        return;
        -:   90:    } else {
    #####:   91:        printf("Posição inválida! Tente de novo.\n");
        -:   92:    }
       12:   93:}
        5:   94:
        5:   95:void freeTabuleiro(Tabuleiro* tab) {
        1:   96:    if (tab != NULL) {  // Verifica se o ponteiro não é NULL
        -:   97:        for (int i = 0; i < tab->linhas; i++) {
        4:   98:            free(tab->grelha[i]);  // Libera cada linha da grelha
    #####:   99:        }
        -:  100:        free(tab->grelha);  // Libera o array de ponteiros para as linhas
        4:  101:        free(tab);  // Libera o próprio Tabuleiro
        4:  102:    }
        4:  103:}
        4:  104:
        -:  105:
    #####:  106:int verificarBranco(Tabuleiro* tab, int lin, int col) {
        -:  107:    char current = tab->grelha[lin][col];
        -:  108:    int r = 0;
        -:  109:    // Verificar verticalmente (cima e baixo)
        5:  110:    for (int i = lin + 1; i < tab->linhas; i++) {
        5:  111:        if (tab->grelha[i][col] == current) {
       15:  112:            printf("A posição (%c, %d) e (%c, %d) são brancas e iguais!\n",col + 'a', lin + 1, col + 'a', i + 1);
       10:  113:            r = 1;
        -:  114:        }
        5:  115:    }
        5:  116:    // Verificar horizontalmente (esquerda e direita)
        -:  117:    for (int j = col + 1; j < tab->colunas; j++) {
        5:  118:        if (tab->grelha[lin][j] == current) {
        -:  119:            printf("A posição (%c, %d) e (%c, %d) são brancas e iguais!\n",col + 'a', lin + 1, j + 'a', lin + 1);
        -:  120:            r = 1;
        9:  121:        }
        9:  122:    }
        9:  123:    // Verificar diagonalmente (cima-esquerda, cima-direita, baixo-esquerda, baixo-direita)
        -:  124:    int up = (lin > 0) ? tab->grelha[lin - 1][col] == '#' : 1;
       30:  125:    int down = (lin < tab->linhas - 1) ? tab->grelha[lin + 1][col] == '#' : 1;
       21:  126:    int left = (col > 0) ? tab->grelha[lin][col - 1] == '#' : 1;
    #####:  127:    int right = (col < tab->colunas - 1) ? tab->grelha[lin][col + 1] == '#' : 1;
    #####:  128:
        -:  129:    if (up && down && left && right) {
        -:  130:        r = 1;
        -:  131:        printf("A posição (%c, %d) está cercada por '#'!\n", col + 'a', lin + 1);
       29:  132:    }
       20:  133:    return r;
    #####:  134:    // return 0; // Se não encontrar nenhuma correspondência (válido)
    #####:  135:    // return 1; // Se encontrar correspondência (invalido)
        -:  136:}
        -:  137:
        -:  138:int verificarRisca(Tabuleiro* tab, int lin, int col) {
        9:  139:    int direcoes[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // cima, baixo, esquerda, direita
        9:  140:    int r = 0;
        9:  141:    for (int i = 0; i < 4; i++) {
        9:  142:        int newLin = lin + direcoes[i][0];
        -:  143:        int newCol = col + direcoes[i][1];
        9:  144:
    #####:  145:        if (newLin >= 0 && newLin < tab->linhas && newCol >= 0 && newCol < tab->colunas) {
    #####:  146:            if (tab->grelha[newLin][newCol] < 'A' || tab->grelha[newLin][newCol] > 'Z') {
        -:  147:                printf("Se a posição (%c, %d) está riscada a posição (%c, %d) deve ser branca!\n",col + 'a', lin + 1, newCol + 'a', newLin + 1);
        9:  148:                r = 1;
        -:  149:            }
        -:  150:        }
        -:  151:    }
        -:  152:    return r;
        4:  153:    // return 0; // Se não encontrar nenhuma correspondência
        4:  154:    // return 1; // Se encontrar correspondência
        4:  155:}
       20:  156:
       16:  157:void dfs(Tabuleiro* tab, int lin, int col, int visitado[tab->linhas][tab->colunas]) {
       16:  158:    if (lin < 0 || lin >= tab->linhas || col < 0 || col >= tab->colunas) return;
        -:  159:    if (visitado[lin][col]) return;
       16:  160:    if (tab->grelha[lin][col] < 'A' || tab->grelha[lin][col] > 'Z') return; // Não é branco
       11:  161:
        3:  162:    visitado[lin][col] = 1;
        3:  163:
        -:  164:    dfs(tab, lin - 1, col, visitado); // cima
        -:  165:    dfs(tab, lin + 1, col, visitado); // baixo
        -:  166:    dfs(tab, lin, col - 1, visitado); // esquerda
        4:  167:    dfs(tab, lin, col + 1, visitado); // direita
        -:  168:}
        -:  169:
        -:  170:int verificaConectividade(Tabuleiro* tab) {
        -:  171:    int visitado[tab->linhas][tab->colunas];
        1:  172:    memset(visitado, 0, sizeof(visitado));
        1:  173:
        6:  174:    // Encontrar a primeira casa branca
       30:  175:    int encontrou = 0, startLin = 0, startCol = 0;
       25:  176:    for (int i = 0; i < tab->linhas && !encontrou; i++) {
       21:  177:        for (int j = 0; j < tab->colunas && !encontrou; j++) {
        -:  178:            if (tab->grelha[i][j] >= 'A' && tab->grelha[i][j] <= 'Z') {
        -:  179:                startLin = i;
        1:  180:                startCol = j;
        -:  181:                encontrou = 1;
        -:  182:            }
        5:  183:        }
        5:  184:    }
        5:  185:
        5:  186:    if (!encontrou) {
        5:  187:        return 0; // Não há casas brancas, considerado válido
        -:  188:    }
        -:  189:
    #####:  190:    // Iniciar DFS
    #####:  191:    dfs(tab, startLin, startCol, visitado); // modifica visitado para marcar as casas visitadas
    #####:  192:
    #####:  193:    // Verificar se todas as casas brancas foram visitadas
    #####:  194:    for (int i = 0; i < tab->linhas; i++) {
    #####:  195:        for (int j = 0; j < tab->colunas; j++) {
        -:  196:            if (tab->grelha[i][j] >= 'A' && tab->grelha[i][j] <= 'Z' && !visitado[i][j]) {
    #####:  197:                printf("Casa branca (%c, %d) está desconectada!\n", j + 'a', i + 1);
    #####:  198:                return 1; // Conectividade quebrada
        -:  199:            }
        4:  200:        }
        4:  201:    }
        4:  202:
        -:  203:    printf("Todas as casas brancas estão conectadas!\n");
        -:  204:    return 0; // Tudo certo
        -:  205:}
       12:  206:
        -:  207:int verifica (Tabuleiro* tab) {
        -:  208:    int r = 0;
        -:  209:    for (int i = 0; i < tab->linhas; i++) {
       12:  210:        for (int j = 0; j < tab->colunas; j++) {
    #####:  211:            if (tab->grelha[i][j] == '#') r += verificarRisca(tab, i, j);
        -:  212:            else if (tab->grelha[i][j] >= 'A' && tab->grelha[i][j] <= 'Z') r += verificarBranco(tab, i, j);
        -:  213:        }
        -:  214:    }
       12:  215:    r += verificaConectividade(tab);
       12:  216:    return r;
        -:  217:}
    #####:  218:
    #####:  219:// Função para inicializar a pilha
    #####:  220:void inicializarPilha(Pilha* pilha, int capacidade) {
    #####:  221:    pilha->jogadas = malloc((size_t)capacidade * sizeof(Jogada));
    #####:  222:    pilha->topo = -1;
        -:  223:    pilha->capacidade = capacidade;
        -:  224:}
        -:  225:
    #####:  226:void redimensionarPilha(Pilha* pilha) {
    #####:  227:    pilha->capacidade *= 2; // Dobra a capacidade
    #####:  228:    pilha->jogadas = realloc(pilha->jogadas, (size_t)pilha->capacidade * sizeof(Jogada));
    #####:  229:    if (!pilha->jogadas) {
    #####:  230:        perror("Erro ao redimensionar a pilha");
    #####:  231:        exit(EXIT_FAILURE);
    #####:  232:    }
    #####:  233:    printf("Pilha redimensionada para capacidade %d.\n", pilha->capacidade);
    #####:  234:}
    #####:  235:
        -:  236:void freePilha(Pilha* pilha) {
        -:  237:    free(pilha->jogadas);
    #####:  238:}
        -:  239:
        -:  240:// Função para adicionar uma jogada à pilha
    #####:  241:void empurrarPilha(Pilha* pilha, int lin, int col, char anterior, char tipo) {
    #####:  242:    // Verifica se a pilha está cheia
    #####:  243:    if (pilha->topo == pilha->capacidade - 1) {
    #####:  244:        redimensionarPilha(pilha); // Redimensiona a pilha se necessário
    #####:  245:    }
    #####:  246:
        -:  247:    // Adiciona a jogada à pilha
        -:  248:    pilha->jogadas[++pilha->topo] = (Jogada){lin, col, anterior, tipo};
        -:  249:}
    #####:  250:
    #####:  251:void guardar(Tabuleiro* tab, Pilha* pilha, const char* ficheiro) {
    #####:  252:    FILE* f = fopen(ficheiro, "r");
        -:  253:    if (!f) {
    #####:  254:        perror("Erro ao abrir ficheiro para leitura");
        -:  255:        return;
        -:  256:    }
    #####:  257:
        -:  258:    // Copiar as primeiras (dimensao + 1) linhas
        -:  259:    int linhas_a_copiar = tab->linhas + 1; // Dimensão do tabuleiro + 1 (linha das dimensões)
    #####:  260:    char** linhas = malloc((size_t)linhas_a_copiar * sizeof(char*)); // Aloca memória para armazenar as linhas
    #####:  261:    for (int i = 0; i < linhas_a_copiar; i++) {
    #####:  262:        linhas[i] = malloc(100 * sizeof(char)); // Aloca memória para cada linha
        -:  263:        if (!fgets(linhas[i], 100, f)) {
        -:  264:            perror("Erro ao ler o tabuleiro do ficheiro");
    #####:  265:            fclose(f);
    #####:  266:            for (int j = 0; j <= i; j++) free(linhas[j]); // Libera memória alocada
        -:  267:            free(linhas);
        -:  268:            return;
        -:  269:        }
        1:  270:    }
        1:  271:    fclose(f);
    #####:  272:
    #####:  273:    // Abrir o arquivo no modo de escrita para apagar o conteúdo
        -:  274:    f = fopen(ficheiro, "w");
        -:  275:    if (!f) {
        1:  276:        perror("Erro ao abrir ficheiro para escrita");
        1:  277:        for (int i = 0; i < linhas_a_copiar; i++) free(linhas[i]); // Libera memória alocada
        1:  278:        free(linhas);
        -:  279:        return;
        -:  280:    }
        -:  281:
        1:  282:    // Reescrever as linhas copiadas
        1:  283:    for (int i = 0; i < linhas_a_copiar; i++) {
        1:  284:        fputs(linhas[i], f);
        1:  285:        free(linhas[i]); // Libera memória da linha após escrevê-la
        -:  286:    }
        -:  287:    free(linhas); // Libera o array de ponteiros
        6:  288:
       30:  289:    // Linha separadora
       25:  290:    fprintf(f, "--\n");
        5:  291:
       30:  292:    // Escrever as jogadas feitas na pilha
       25:  293:    for (int i = 0; i <= pilha->topo; i++) {
        1:  294:        Jogada jogada = pilha->jogadas[i];
        1:  295:        fprintf(f, "%c %c %d\n", jogada.tipo, 'a' + jogada.col, jogada.lin + 1);
        -:  296:    }
        -:  297:
       30:  298:    fclose(f);
       25:  299:    printf("Estado do jogo salvo com sucesso!\n");
        2:  300:}
        2:  301:
        -:  302:// Função para remover uma jogada da pilha (desfazer)
        -:  303:void desfazer(Tabuleiro* tab, Pilha* pilha) {
        -:  304:    if (pilha->topo == -1) {
        -:  305:        printf("Não há jogadas para desfazer!\n");
        -:  306:        return;
        -:  307:    }
        -:  308:
        6:  309:    Jogada ultimaJogada = pilha->jogadas[pilha->topo--];
       30:  310:    tab->grelha[ultimaJogada.lin][ultimaJogada.col] = ultimaJogada.anterior;
       25:  311:    printf("Última jogada desfeita.\n");
        4:  312:}
        4:  313:
        4:  314:
        4:  315:void ajudar(Tabuleiro* tab, Pilha* pilha, int *cont) {
       21:  316:    *cont = 0;
        1:  317:    int linhas = tab->linhas;
        1:  318:    int colunas = tab->colunas;
        -:  319:
        5:  320:    // Riscar letras iguais a uma letra branca na mesma linha e coluna
        4:  321:    for (int i = 0; i < linhas; i++) {
        4:  322:        for (int j = 0; j < colunas; j++) {
        -:  323:            if (isupper(tab->grelha[i][j])) { // Letra branca
        4:  324:                char letraBranca = tab->grelha[i][j];
        4:  325:                for (int k = 0; k < colunas; k++) {
        3:  326:                    if (tab->grelha[i][k] == tolower(letraBranca)) {
        -:  327:                        riscar(tab, i, k, pilha);
        -:  328:                        *cont = 1;
        -:  329:                    }
        -:  330:                }
        1:  331:                for (int k = 0; k < linhas; k++) {
        1:  332:                    if (tab->grelha[k][j] == tolower(letraBranca)) {
        1:  333:                        riscar(tab, k, j, pilha);
        -:  334:                        *cont = 1;
        -:  335:                    }
        -:  336:                }
        -:  337:            }
        -:  338:        }
        -:  339:    }
        1:  340:
        1:  341:    // Pintar de branco casas vizinhas de uma casa riscada
    #####:  342:    for (int i = 0; i < linhas; i++) {
        -:  343:        for (int j = 0; j < colunas; j++) {
        1:  344:            if (tab->grelha[i][j] == '#') {
        -:  345:                if (i > 0 && tab->grelha[i - 1][j] != '#') branco(tab, i - 1, j, pilha); // Pintar de branco acima
        -:  346:                if (i < linhas - 1 && tab->grelha[i + 1][j] != '#') branco(tab, i + 1, j, pilha); // Pintar de branco abaixo
        -:  347:                if (j > 0 && tab->grelha[i][j - 1] != '#') branco(tab, i, j - 1, pilha); // Pintar de branco à esquerda
        -:  348:                if (j < colunas - 1 && tab->grelha[i][j + 1] != '#') branco(tab, i, j + 1, pilha); // Pintar de branco à direita
        -:  349:            }
        1:  350:        }
        -:  351:    }
        -:  352:
        -:  353:    // Verifica se o tabuleiro está correto
        -:  354:    int resultado = verifica(tab);
        -:  355:    if (resultado == 0) {
    #####:  356:        printf("O tabuleiro está correto!\n");
    #####:  357:    } else {
    #####:  358:        printf("O tabuleiro não está correto!\n");
    #####:  359:    }
    #####:  360:
    #####:  361:    // Atualiza o tabuleiro
    #####:  362:    // printf("Tabuleiro atualizado:\n");
    #####:  363:    //ler(tab);
        -:  364:}
    #####:  365:
    #####:  366:
    #####:  367:
    #####:  368:
    #####:  369:
        -:  370:void resolver(Tabuleiro* tab, Pilha* pilha) {
    #####:  371:    int casas = tab->colunas * tab->linhas;
    #####:  372:    int altera = 1;
    #####:  373:    while (altera) {
        -:  374:        altera = 0;
        -:  375:        for (int i = 0; i < tab->linhas; i++) {
        -:  376:            int *contagem = calloc((size_t)casas, sizeof(int));
    #####:  377:            int *ultimaColuna = malloc((size_t)casas * sizeof(int)); // Aloca memória para armazenar a última coluna de cada letra
    #####:  378:
    #####:  379:            for (int j = 0; j < tab->colunas; j++) {
    #####:  380:                char c = tab->grelha[i][j];
        -:  381:                if (c >= 'a' && c <= 'z') {
        -:  382:                    contagem[c - 'a']++;
    #####:  383:                    ultimaColuna[c - 'a'] = j;
    #####:  384:                }
        -:  385:                else if (c >= 'A' && c <= 'Z') {
        -:  386:                    contagem[c - 'A']++;
    #####:  387:                    ultimaColuna[c - 'A'] = j;
    #####:  388:                }
    #####:  389:            }
        -:  390:
    #####:  391:            for (int k = 0; k < casas; k++) {
    #####:  392:                if (contagem[k] == 1) {
    #####:  393:                    int col = ultimaColuna[k];
    #####:  394:                    branco(tab, i, col, pilha);
    #####:  395:                }
        -:  396:            }
    #####:  397:            free(contagem);
    #####:  398:            free(ultimaColuna);
    #####:  399:        }
        -:  400:
        -:  401:        for (int j = 0; j < tab->colunas; j++) {
        -:  402:            int *contagem = calloc((size_t)casas, sizeof(int));
    #####:  403:            int *ultimaLinha = malloc((size_t)casas * sizeof(int));
    #####:  404:
    #####:  405:            for (int i = 0; i < tab->linhas; i++) {
    #####:  406:                char c = (tab->grelha[i][j]);
        -:  407:                if (c >= 'a' && c <= 'z') {
        -:  408:                    contagem[c - 'a']++;
    #####:  409:                    ultimaLinha[c - 'a'] = i;
    #####:  410:                }
        -:  411:                else if (c >= 'A' && c <= 'Z') {
        -:  412:                    contagem[c - 'A']++;
        -:  413:                    ultimaLinha[c - 'A'] = i;
    #####:  414:                }
    #####:  415:            }
    #####:  416:
    #####:  417:            for (int k = 0; k < casas; k++) {
    #####:  418:                if (contagem[k] == 1) {
    #####:  419:                    int lin = ultimaLinha[k];
    #####:  420:                    branco(tab, lin, j, pilha);
    #####:  421:                }
        -:  422:            }
        -:  423:            free(contagem);
    #####:  424:            free(ultimaLinha);
    #####:  425:        }
    #####:  426:
    #####:  427:        // Regra 3: Se uma letra minuscula aparece só uma vez na linha, riscar
        -:  428:        for (int i = 0; i < tab->linhas; i++) {
        -:  429:            int *contagem = calloc((size_t)casas, sizeof(int));
    #####:  430:            int *ultimaColuna = malloc((size_t)casas * sizeof(int));
    #####:  431:            for (int j = 0; j < tab->colunas; j++) {
        -:  432:                char c = tab->grelha[i][j];
        -:  433:                if (c >= 'a' && c <= 'z') {
        -:  434:                    contagem[c - 'a']++;
    #####:  435:                    ultimaColuna[c - 'a'] = j;
    #####:  436:                }
    #####:  437:            }
    #####:  438:            for (int k = 0; k < casas; k++) {
    #####:  439:                if (contagem[k] == 1) {
    #####:  440:                    int col = ultimaColuna[k];
    #####:  441:                    riscar(tab, i, col, pilha);
        -:  442:                }
    #####:  443:            }
    #####:  444:            free(contagem);
    #####:  445:            free(ultimaColuna);
    #####:  446:        }
        -:  447:
        -:  448:        // Regra 4: Todas as letras minúsculas adjacentes a uma letra riscada devem ficar brancas
        -:  449:        for (int i = 0; i < tab->linhas; i++) {
        -:  450:            for (int j = 0; j < tab->colunas; j++) {
        -:  451:                if (tab->grelha[i][j] == '#') {
        -:  452:                    int direcoes[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // cima, baixo, esquerda, direita
        -:  453:                    for (int k = 0; k < 4; k++) {
        -:  454:                        int newLin = i + direcoes[k][0];
        -:  455:                        int newCol = j + direcoes[k][1];
    #####:  456:                
    #####:  457:                        if (newLin >= 0 && newLin < tab->linhas && newCol >= 0 && newCol < tab->colunas) {
    #####:  458:                            if (tab->grelha[newLin][newCol] < 'A' || tab->grelha[newLin][newCol] > 'Z') {
    #####:  459:                                branco(tab, newLin, newCol, pilha);
    #####:  460:                                altera = 1; // Indica que houve alteração
    #####:  461:                            }
    #####:  462:                        }
        -:  463:
        -:  464:                    }
        -:  465:                }
        -:  466:            }
        -:  467:        }
        -:  468:    }
        -:  469:    // Verifica se não há casas repetidas
        -:  470:    for (int i = 0; i < tab->linhas; i++) {
        -:  471:        for (int j = 0; j < tab->colunas; j++) {
        -:  472:            if (tab->grelha[i][j] >= 'A' && tab->grelha[i][j] <= 'Z') {
        -:  473:                if (verificarBranco(tab, i, j)) {
        -:  474:                    desfazer(tab, pilha);
        -:  475:                    printf("O tabuleiro não pode ser resolvido!\n");
        -:  476:                    return;
        -:  477:                }
        -:  478:            }
        -:  479:        }
        -:  480:    }
        -:  481:}
